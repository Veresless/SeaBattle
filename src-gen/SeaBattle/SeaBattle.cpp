/*
 * Autogenerated by ThriftMeGenerator (v2.13.4.0)
 * 
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING!
 * 
 * Copyright 2020 Daimler AG
 * All Rights Reserved.
 * NOTICE:  All added/modified information contained herein is and remains the proprietary of Daimler AG.
 * The intellectual and technical concepts contained herein are proprietary to Daimler AG and may be covered by German and Foreign Patents, patent applications, and are protected by trade secret or copyright law.
 */

#include "SeaBattle.h"

#include <exceptions/TException.h>
#include <locks/Locks.h>
#include <utility/TFormatHelper.h>


namespace SeaBattle
{
	using namespace ::thrift;

	namespace SeaBattleParameters
	{
		class TM_DECL_LOCAL oponentConectedEvent_args : public ::thrift::protocol::TBase
		{
		private:
			int16_t _clientID;

		public:
			typedef struct Isset
			{
				bool clientID;
				Isset() : clientID(false){ }
				Isset(bool initValue) : clientID(initValue){ }
			} Isset;

			Isset __isset;

			const int16_t& ClientIDByRef() const
			{
				return _clientID;
			}
			oponentConectedEvent_args& setClientID(const int16_t value)
			{
				 _clientID = (int16_t) value;
				__isset.clientID = true;
				return *this;
			}

			oponentConectedEvent_args(const int16_t clientID)
			 : _clientID(clientID), __isset(true)
			{
			}

			oponentConectedEvent_args()
			 : _clientID(0), __isset(false)
			{
			}

			virtual void read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot) override;
			virtual void write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const override;
		};

		class TM_DECL_LOCAL oponentShootEvent_args : public ::thrift::protocol::TBase
		{
		private:
			int16_t _clientID;
			int32_t _x;
			int32_t _y;

		public:
			typedef struct Isset
			{
				bool clientID;
				bool x;
				bool y;
				Isset() : clientID(false), x(false), y(false){ }
				Isset(bool initValue) : clientID(initValue), x(initValue), y(initValue){ }
			} Isset;

			Isset __isset;

			const int16_t& ClientIDByRef() const
			{
				return _clientID;
			}
			oponentShootEvent_args& setClientID(const int16_t value)
			{
				 _clientID = (int16_t) value;
				__isset.clientID = true;
				return *this;
			}

			const int32_t& XByRef() const
			{
				return _x;
			}
			oponentShootEvent_args& setX(const int32_t value)
			{
				 _x = (int32_t) value;
				__isset.x = true;
				return *this;
			}

			const int32_t& YByRef() const
			{
				return _y;
			}
			oponentShootEvent_args& setY(const int32_t value)
			{
				 _y = (int32_t) value;
				__isset.y = true;
				return *this;
			}

			oponentShootEvent_args(const int32_t x, const int32_t y, const int16_t clientID)
			 : _clientID(clientID), _x(x), _y(y), __isset(true)
			{
			}

			oponentShootEvent_args()
			 : _clientID(0), _x(0), _y(0), __isset(false)
			{
			}

			virtual void read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot) override;
			virtual void write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const override;
		};

		class TM_DECL_LOCAL setShootResponse_args : public ::thrift::protocol::TBase
		{
		private:
			::SeaBattle::ShootRezult::type _rezult;
			int16_t _clientID;

		public:
			typedef struct Isset
			{
				bool rezult;
				bool clientID;
				Isset() : rezult(false), clientID(false){ }
				Isset(bool initValue) : rezult(initValue), clientID(initValue){ }
			} Isset;

			Isset __isset;

			const ::SeaBattle::ShootRezult::type& RezultByRef() const
			{
				return _rezult;
			}
			setShootResponse_args& setRezult(const ::SeaBattle::ShootRezult::type& value)
			{
				 _rezult = (::SeaBattle::ShootRezult::type) value;
				__isset.rezult = true;
				return *this;
			}
			setShootResponse_args& setRezult(::SeaBattle::ShootRezult::type&& value)
			{
				 _rezult = std::move(value);
				__isset.rezult = true;
				return *this;
			}

			const int16_t& ClientIDByRef() const
			{
				return _clientID;
			}
			setShootResponse_args& setClientID(const int16_t value)
			{
				 _clientID = (int16_t) value;
				__isset.clientID = true;
				return *this;
			}

			setShootResponse_args(const ::SeaBattle::ShootRezult::type& rezult, const int16_t clientID)
			 : _rezult(rezult), _clientID(clientID), __isset(true)
			{
			}

			setShootResponse_args()
			 : _rezult(), _clientID(0), __isset(false)
			{
			}

			virtual void read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot) override;
			virtual void write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const override;
		};

		typedef /* SeaBattle.SeaBattle/IN/x/int32_t/1/y/int32_t/2/clientID/int16_t/3 */ oponentShootEvent_args setShoot_args;
		typedef /* SeaBattle.SeaBattle/IN/rezult/::SeaBattle::ShootRezult::type/1/clientID/int16_t/2 */ setShootResponse_args shootResponseEvent_args;
		class TM_DECL_LOCAL gameOver_args : public ::thrift::protocol::TBase
		{
		private:
			bool _rezult;
			int16_t _clientID;

		public:
			typedef struct Isset
			{
				bool rezult;
				bool clientID;
				Isset() : rezult(false), clientID(false){ }
				Isset(bool initValue) : rezult(initValue), clientID(initValue){ }
			} Isset;

			Isset __isset;

			const bool& RezultByRef() const
			{
				return _rezult;
			}
			gameOver_args& setRezult(const bool value)
			{
				 _rezult = (bool) value;
				__isset.rezult = true;
				return *this;
			}

			const int16_t& ClientIDByRef() const
			{
				return _clientID;
			}
			gameOver_args& setClientID(const int16_t value)
			{
				 _clientID = (int16_t) value;
				__isset.clientID = true;
				return *this;
			}

			gameOver_args(const bool rezult, const int16_t clientID)
			 : _rezult(rezult), _clientID(clientID), __isset(true)
			{
			}

			gameOver_args()
			 : _rezult(false), _clientID(0), __isset(false)
			{
			}

			virtual void read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot) override;
			virtual void write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const override;
		};

		typedef /* SeaBattle.SeaBattle/IN/clientID/int16_t/1 */ oponentConectedEvent_args subscribe_args;
		typedef /* SeaBattle.SeaBattle/IN/clientID/int16_t/1 */ oponentConectedEvent_args unsubscribe_args;
	}
	SeaBattleClient::SeaBattleClient(const std::shared_ptr<::thrift::TServiceBroker>& broker,
		const std::string& address,
		const std::shared_ptr< ::thrift::locks::ILockable >& lockable, const ::thrift::utility::TOptionContainer& transportOptions)
		: TClient(broker, address, lockable, transportOptions)
	{
		tmRegisterCallback(SeaBattleFunctionIds::OPONENT_CONECTED_EVENT_ID,
			thrift::bind(&SeaBattleClient::process_oponentConectedEvent, this, ::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::OPONENT_SHOOT_EVENT_ID,
			thrift::bind(&SeaBattleClient::process_oponentShootEvent, this, ::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::SHOOT_RESPONSE_EVENT_ID,
			thrift::bind(&SeaBattleClient::process_shootResponseEvent, this, ::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::GAME_OVER_ID,
			thrift::bind(&SeaBattleClient::process_gameOver, this, ::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
	}
	std::shared_ptr<SeaBattleClient> SeaBattleClient::createClient(const std::shared_ptr<::thrift::TServiceBroker>& broker, const std::string& address, const SeaBattleClient::Factory& factory, const std::shared_ptr< ::thrift::locks::ILockable >& lockable)
	{
		::thrift::utility::TUri uri(address);
		std::string uriString = uri.toString();
		return ::thrift::TClient::createClient<SeaBattleClient>(broker, uriString, factory, lockable);
	}

	std::shared_ptr<SeaBattleClient> SeaBattleClient::createClient(const std::shared_ptr<::thrift::TServiceBroker>& broker, const ::thrift::TServiceReference& serviceReference, const SeaBattleClient::Factory& factory, const std::shared_ptr< ::thrift::locks::ILockable >& lockable)
	{
		return ::thrift::TClient::createClient4Reference<SeaBattleClient>(broker, serviceReference, ServiceIds::getSeaBattleVersion(),
		factory, lockable);
	}

	bool SeaBattleClient::verifyClient()
	{
		std::shared_ptr<::thrift::transport::TTransport> transport = getTransport();
		if (!transport || transport->getState() != ::thrift::transport::TTransportState::CONNECTED) return false;
		try
		{
			if (ServiceIds::getSeaBattleVersion().serviceType != "SeaBattle.SeaBattle") return false;
		}
		catch (::thrift::exceptions::TException&)
		{
			return false;
		}
		return true;
	}

	void SeaBattleClient::process_oponentConectedEvent(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		(void)seqId;
		(void)serviceId;
		(void)context;
		(void)exFlags;

		::thrift::protocol::TProtocol* iProt = context.inputTransport->getProtocol().get();

		SeaBattleParameters::oponentConectedEvent_args args;
		args.read(*message, iProt);
		iProt->readMessageEnd(*message);


		this->oponentConectedEvent(args.ClientIDByRef());
	}

	void SeaBattleClient::oponentConectedEvent(const int16_t clientID)
	{
		(void)clientID;
	}

	void SeaBattleClient::process_oponentShootEvent(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		(void)seqId;
		(void)serviceId;
		(void)context;
		(void)exFlags;

		::thrift::protocol::TProtocol* iProt = context.inputTransport->getProtocol().get();

		SeaBattleParameters::oponentShootEvent_args args;
		args.read(*message, iProt);
		iProt->readMessageEnd(*message);


		this->oponentShootEvent(args.XByRef(), args.YByRef(), args.ClientIDByRef());
	}

	void SeaBattleClient::oponentShootEvent(const int32_t x,
		const int32_t y,
		const int16_t clientID)
	{
		(void)x;
		(void)y;
		(void)clientID;
	}

	void SeaBattleClient::process_shootResponseEvent(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		(void)seqId;
		(void)serviceId;
		(void)context;
		(void)exFlags;

		::thrift::protocol::TProtocol* iProt = context.inputTransport->getProtocol().get();

		SeaBattleParameters::shootResponseEvent_args args;
		args.read(*message, iProt);
		iProt->readMessageEnd(*message);


		this->shootResponseEvent(args.RezultByRef(), args.ClientIDByRef());
	}

	void SeaBattleClient::shootResponseEvent(const ::SeaBattle::ShootRezult::type& rezult,
		const int16_t clientID)
	{
		(void)rezult;
		(void)clientID;
	}

	void SeaBattleClient::process_gameOver(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		(void)seqId;
		(void)serviceId;
		(void)context;
		(void)exFlags;

		::thrift::protocol::TProtocol* iProt = context.inputTransport->getProtocol().get();

		SeaBattleParameters::gameOver_args args;
		args.read(*message, iProt);
		iProt->readMessageEnd(*message);


		this->gameOver(args.RezultByRef(), args.ClientIDByRef());
	}

	void SeaBattleClient::gameOver(const bool rezult,
		const int16_t clientID)
	{
		(void)rezult;
		(void)clientID;
	}

	void SeaBattleClient::setShootResponse(const ::SeaBattle::ShootRezult::type& rezult,
		const int16_t clientID)
	{
		std::shared_ptr<setShootResponse_AsyncResult> ar = send_setShootResponse(rezult, clientID);
		return recv_setShootResponse(ar);
	}

	std::shared_ptr<SeaBattleClient::setShootResponse_AsyncResult> SeaBattleClient::send_setShootResponse(const ::SeaBattle::ShootRezult::type& rezult,
		const int16_t clientID)
	{
		return SeaBattleClient::send_setShootResponse(rezult, clientID, ::thrift::TAsyncResult::SuccessCallback(), ::thrift::TAsyncResult::ErrorCallback(), 0);
	}

	/**
	 * @param onSuccess The function which is executed if the request succeeds
	 * @param onError The function which is executed if the request fails
	 * @param userState Any object the user wants to store for the duration of the operation
	 * @param timeout Override of the timeout value specified in the IDL (negative to keep default)
	 */
	std::shared_ptr<SeaBattleClient::setShootResponse_AsyncResult> SeaBattleClient::send_setShootResponse(const ::SeaBattle::ShootRezult::type& rezult,
		const int16_t clientID,
		TAsyncResult::SuccessCallback onSuccess,
		::thrift::TAsyncResult::ErrorCallback onError,
		void* userState,
		int32_t timeout)
	{

		SeaBattleParameters::setShootResponse_args args( rezult,clientID);
		std::shared_ptr<SeaBattleClient::setShootResponse_CompletableAsyncResult> aresult = std::make_shared<setShootResponse_CompletableAsyncResult>(shared_from_this(), &SeaBattleClient::decode_setShootResponse,onSuccess, onError, userState);
		::thrift::TClient::sendRequest(aresult, static_cast<std::string>("setShootResponse"),SeaBattleFunctionIds::SET_SHOOT_RESPONSE_ID, args, 0, timeout); //Timeout value is picked from the IDL
		return aresult;
	}

	void SeaBattleClient::recv_setShootResponse(
		std::shared_ptr <SeaBattleClient::setShootResponse_AsyncResult> & asyncResult)
	{
		::thrift::TAsyncResult::OperationState state = asyncResult->waitForCompletion();
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_SUCCESS)
			return;
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_THRIFTERROR)
			throw asyncResult->exceptionResult;
		throw ::thrift::exceptions::TException(::thrift::exceptions::TErrorCode::E_OPERATION_MISSING_RESULT,
			"Unable to interpret server response, interface mismatch?");
	}

	void SeaBattleClient::decode_setShootResponse(
		const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message,
		const ::thrift::protocol::TMessageHeader& messageHeader,
		const std::shared_ptr< ::thrift::transport::TTransport >& iTrans,
		const std::shared_ptr<::thrift::TAsyncResult>& asyncResult)
	{
		std::shared_ptr<setShootResponse_CompletableAsyncResult> ar =
			dynamic_pointer_cast<setShootResponse_CompletableAsyncResult, ::thrift::TAsyncResult>(asyncResult);
		::thrift::protocol::TMessageDescription thme_description;
		if (!ar)
			throw ::thrift::exceptions::TException(
				::thrift::exceptions::TErrorCode::E_CLIENT_ASYNCRESULT_TYPE_INVALID);
		
		{
			::thrift::ulock asyncResultLock(ar->getMutex());
			ar->resultStruct.read(*message, iTrans->getProtocol().get());
			iTrans->getProtocol()->readMessageEnd(*message);

			ar->setCompletedWithSuccess(asyncResultLock);
			return;
		}
	}

	void SeaBattleClient::setShoot(const int32_t x,
		const int32_t y,
		const int16_t clientID)
	{
		std::shared_ptr<setShoot_AsyncResult> ar = send_setShoot(x, y, clientID);
		return recv_setShoot(ar);
	}

	std::shared_ptr<SeaBattleClient::setShoot_AsyncResult> SeaBattleClient::send_setShoot(const int32_t x,
		const int32_t y,
		const int16_t clientID)
	{
		return SeaBattleClient::send_setShoot(x, y, clientID, ::thrift::TAsyncResult::SuccessCallback(), ::thrift::TAsyncResult::ErrorCallback(), 0);
	}

	/**
	 * @param onSuccess The function which is executed if the request succeeds
	 * @param onError The function which is executed if the request fails
	 * @param userState Any object the user wants to store for the duration of the operation
	 * @param timeout Override of the timeout value specified in the IDL (negative to keep default)
	 */
	std::shared_ptr<SeaBattleClient::setShoot_AsyncResult> SeaBattleClient::send_setShoot(const int32_t x,
		const int32_t y,
		const int16_t clientID,
		TAsyncResult::SuccessCallback onSuccess,
		::thrift::TAsyncResult::ErrorCallback onError,
		void* userState,
		int32_t timeout)
	{

		SeaBattleParameters::setShoot_args args( x,y,clientID);
		std::shared_ptr<SeaBattleClient::setShoot_CompletableAsyncResult> aresult = std::make_shared<setShoot_CompletableAsyncResult>(shared_from_this(), &SeaBattleClient::decode_setShoot,onSuccess, onError, userState);
		::thrift::TClient::sendRequest(aresult, static_cast<std::string>("setShoot"),SeaBattleFunctionIds::SET_SHOOT_ID, args, 0, timeout); //Timeout value is picked from the IDL
		return aresult;
	}

	void SeaBattleClient::recv_setShoot(
		std::shared_ptr <SeaBattleClient::setShoot_AsyncResult> & asyncResult)
	{
		::thrift::TAsyncResult::OperationState state = asyncResult->waitForCompletion();
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_SUCCESS)
			return;
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_THRIFTERROR)
			throw asyncResult->exceptionResult;
		throw ::thrift::exceptions::TException(::thrift::exceptions::TErrorCode::E_OPERATION_MISSING_RESULT,
			"Unable to interpret server response, interface mismatch?");
	}

	void SeaBattleClient::decode_setShoot(
		const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message,
		const ::thrift::protocol::TMessageHeader& messageHeader,
		const std::shared_ptr< ::thrift::transport::TTransport >& iTrans,
		const std::shared_ptr<::thrift::TAsyncResult>& asyncResult)
	{
		std::shared_ptr<setShoot_CompletableAsyncResult> ar =
			dynamic_pointer_cast<setShoot_CompletableAsyncResult, ::thrift::TAsyncResult>(asyncResult);
		::thrift::protocol::TMessageDescription thme_description;
		if (!ar)
			throw ::thrift::exceptions::TException(
				::thrift::exceptions::TErrorCode::E_CLIENT_ASYNCRESULT_TYPE_INVALID);
		
		{
			::thrift::ulock asyncResultLock(ar->getMutex());
			ar->resultStruct.read(*message, iTrans->getProtocol().get());
			iTrans->getProtocol()->readMessageEnd(*message);

			ar->setCompletedWithSuccess(asyncResultLock);
			return;
		}
	}

	void SeaBattleClient::subscribe(const int16_t clientID)
	{
		std::shared_ptr<subscribe_AsyncResult> ar = send_subscribe(clientID);
		return recv_subscribe(ar);
	}

	std::shared_ptr<SeaBattleClient::subscribe_AsyncResult> SeaBattleClient::send_subscribe(const int16_t clientID)
	{
		return SeaBattleClient::send_subscribe(clientID, ::thrift::TAsyncResult::SuccessCallback(), ::thrift::TAsyncResult::ErrorCallback(), 0);
	}

	/**
	 * @param onSuccess The function which is executed if the request succeeds
	 * @param onError The function which is executed if the request fails
	 * @param userState Any object the user wants to store for the duration of the operation
	 * @param timeout Override of the timeout value specified in the IDL (negative to keep default)
	 */
	std::shared_ptr<SeaBattleClient::subscribe_AsyncResult> SeaBattleClient::send_subscribe(const int16_t clientID,
		TAsyncResult::SuccessCallback onSuccess,
		::thrift::TAsyncResult::ErrorCallback onError,
		void* userState,
		int32_t timeout)
	{

		SeaBattleParameters::subscribe_args args( clientID);
		std::shared_ptr<SeaBattleClient::subscribe_CompletableAsyncResult> aresult = std::make_shared<subscribe_CompletableAsyncResult>(shared_from_this(), &SeaBattleClient::decode_subscribe,onSuccess, onError, userState);
		::thrift::TClient::sendRequest(aresult, static_cast<std::string>("subscribe"),SeaBattleFunctionIds::SUBSCRIBE_ID, args, 0, timeout); //Timeout value is picked from the IDL
		return aresult;
	}

	void SeaBattleClient::recv_subscribe(
		std::shared_ptr <SeaBattleClient::subscribe_AsyncResult> & asyncResult)
	{
		::thrift::TAsyncResult::OperationState state = asyncResult->waitForCompletion();
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_SUCCESS)
			return;
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_THRIFTERROR)
			throw asyncResult->exceptionResult;
		throw ::thrift::exceptions::TException(::thrift::exceptions::TErrorCode::E_OPERATION_MISSING_RESULT,
			"Unable to interpret server response, interface mismatch?");
	}

	void SeaBattleClient::decode_subscribe(
		const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message,
		const ::thrift::protocol::TMessageHeader& messageHeader,
		const std::shared_ptr< ::thrift::transport::TTransport >& iTrans,
		const std::shared_ptr<::thrift::TAsyncResult>& asyncResult)
	{
		std::shared_ptr<subscribe_CompletableAsyncResult> ar =
			dynamic_pointer_cast<subscribe_CompletableAsyncResult, ::thrift::TAsyncResult>(asyncResult);
		::thrift::protocol::TMessageDescription thme_description;
		if (!ar)
			throw ::thrift::exceptions::TException(
				::thrift::exceptions::TErrorCode::E_CLIENT_ASYNCRESULT_TYPE_INVALID);
		
		{
			::thrift::ulock asyncResultLock(ar->getMutex());
			ar->resultStruct.read(*message, iTrans->getProtocol().get());
			iTrans->getProtocol()->readMessageEnd(*message);

			ar->setCompletedWithSuccess(asyncResultLock);
			return;
		}
	}

	void SeaBattleClient::unsubscribe(const int16_t clientID)
	{
		std::shared_ptr<unsubscribe_AsyncResult> ar = send_unsubscribe(clientID);
		return recv_unsubscribe(ar);
	}

	std::shared_ptr<SeaBattleClient::unsubscribe_AsyncResult> SeaBattleClient::send_unsubscribe(const int16_t clientID)
	{
		return SeaBattleClient::send_unsubscribe(clientID, ::thrift::TAsyncResult::SuccessCallback(), ::thrift::TAsyncResult::ErrorCallback(), 0);
	}

	/**
	 * @param onSuccess The function which is executed if the request succeeds
	 * @param onError The function which is executed if the request fails
	 * @param userState Any object the user wants to store for the duration of the operation
	 * @param timeout Override of the timeout value specified in the IDL (negative to keep default)
	 */
	std::shared_ptr<SeaBattleClient::unsubscribe_AsyncResult> SeaBattleClient::send_unsubscribe(const int16_t clientID,
		TAsyncResult::SuccessCallback onSuccess,
		::thrift::TAsyncResult::ErrorCallback onError,
		void* userState,
		int32_t timeout)
	{

		SeaBattleParameters::unsubscribe_args args( clientID);
		std::shared_ptr<SeaBattleClient::unsubscribe_CompletableAsyncResult> aresult = std::make_shared<unsubscribe_CompletableAsyncResult>(shared_from_this(), &SeaBattleClient::decode_unsubscribe,onSuccess, onError, userState);
		::thrift::TClient::sendRequest(aresult, static_cast<std::string>("unsubscribe"),SeaBattleFunctionIds::UNSUBSCRIBE_ID, args, 0, timeout); //Timeout value is picked from the IDL
		return aresult;
	}

	void SeaBattleClient::recv_unsubscribe(
		std::shared_ptr <SeaBattleClient::unsubscribe_AsyncResult> & asyncResult)
	{
		::thrift::TAsyncResult::OperationState state = asyncResult->waitForCompletion();
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_SUCCESS)
			return;
		if (state == ::thrift::TAsyncResult::T_ASYNCRESULT_COMPLETED_THRIFTERROR)
			throw asyncResult->exceptionResult;
		throw ::thrift::exceptions::TException(::thrift::exceptions::TErrorCode::E_OPERATION_MISSING_RESULT,
			"Unable to interpret server response, interface mismatch?");
	}

	void SeaBattleClient::decode_unsubscribe(
		const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message,
		const ::thrift::protocol::TMessageHeader& messageHeader,
		const std::shared_ptr< ::thrift::transport::TTransport >& iTrans,
		const std::shared_ptr<::thrift::TAsyncResult>& asyncResult)
	{
		std::shared_ptr<unsubscribe_CompletableAsyncResult> ar =
			dynamic_pointer_cast<unsubscribe_CompletableAsyncResult, ::thrift::TAsyncResult>(asyncResult);
		::thrift::protocol::TMessageDescription thme_description;
		if (!ar)
			throw ::thrift::exceptions::TException(
				::thrift::exceptions::TErrorCode::E_CLIENT_ASYNCRESULT_TYPE_INVALID);
		
		{
			::thrift::ulock asyncResultLock(ar->getMutex());
			ar->resultStruct.read(*message, iTrans->getProtocol().get());
			iTrans->getProtocol()->readMessageEnd(*message);

			ar->setCompletedWithSuccess(asyncResultLock);
			return;
		}
	}

	SeaBattleProcessor::SeaBattleProcessor(const std::shared_ptr<::thrift::TServiceBroker>& broker, const std::shared_ptr< ::thrift::locks::ILockable >& lockable) : ::thrift::TServiceProcessor(broker, lockable)
	{
		tmRegisterCallback(::thrift::TServiceProcessor::GET_SERVICE_DESCRIPTOR_ID,
			::thrift::bind(&::thrift::TServiceProcessor::processServiceDescriptorRequest, this,
			::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::SET_SHOOT_RESPONSE_ID,
			::thrift::bind(&SeaBattleProcessor::process_setShootResponse, this,
			::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::SET_SHOOT_ID,
			::thrift::bind(&SeaBattleProcessor::process_setShoot, this,
			::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::SUBSCRIBE_ID,
			::thrift::bind(&SeaBattleProcessor::process_subscribe, this,
			::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
		tmRegisterCallback(SeaBattleFunctionIds::UNSUBSCRIBE_ID,
			::thrift::bind(&SeaBattleProcessor::process_unsubscribe, this,
			::thrift::_1, ::thrift::_2, ::thrift::_3, ::thrift::_4, ::thrift::_5), 0);
	}

	void SeaBattleProcessor::process_setShootResponse(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		::thrift::protocol::TProtocol* iprot = context.inputTransport->getProtocol().get();

		SeaBattleParameters::setShootResponse_args args;
		args.read(*message, iprot);
		iprot->readMessageEnd(*message);
		::thrift::protocol::TMessageHeader thme_header(serviceId, SeaBattleFunctionIds::SET_SHOOT_RESPONSE_ID,::thrift::protocol::T_CALL,seqId);
		::thrift::protocol::TMessageDescription thme_description;
		try
		{
			::thrift::protocol::TProtocol* oprot = context.outputTransport->getProtocol().get();
			::thrift::protocol::TSerializationStatePtr thme_state = oprot->createState();
			std::shared_ptr< ::thrift::transport::TMessageBuffer > reply = std::make_shared<::thrift::transport::TMessageBuffer>(context.outputTransport->getAllocator());
			if (reply)
			{
				thme_header.type = ::thrift::protocol::T_REPLY;
				SeaBattleParameters::setShootResponse_result result_args;
				this->setShootResponse(args.RezultByRef(), args.ClientIDByRef(), context);
				oprot->writeMessageBegin(thme_state,*reply,thme_header,thme_description);
				result_args.write(thme_state, *reply, oprot);
				oprot->writeMessageEnd(thme_state,*reply);
				context.outputTransport->sendMessage(reply);
			}
		}
		catch (const ::thrift::exceptions::TException& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing\n") +"\nException Message: " + ex.toString());
			}
		}
		catch (const std::exception& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing \n") +"\nException Message: " + ex.what());
			}
		}
	}

	void SeaBattleProcessor::process_setShoot(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		::thrift::protocol::TProtocol* iprot = context.inputTransport->getProtocol().get();

		SeaBattleParameters::setShoot_args args;
		args.read(*message, iprot);
		iprot->readMessageEnd(*message);
		::thrift::protocol::TMessageHeader thme_header(serviceId, SeaBattleFunctionIds::SET_SHOOT_ID,::thrift::protocol::T_CALL,seqId);
		::thrift::protocol::TMessageDescription thme_description;
		try
		{
			::thrift::protocol::TProtocol* oprot = context.outputTransport->getProtocol().get();
			::thrift::protocol::TSerializationStatePtr thme_state = oprot->createState();
			std::shared_ptr< ::thrift::transport::TMessageBuffer > reply = std::make_shared<::thrift::transport::TMessageBuffer>(context.outputTransport->getAllocator());
			if (reply)
			{
				thme_header.type = ::thrift::protocol::T_REPLY;
				SeaBattleParameters::setShoot_result result_args;
				this->setShoot(args.XByRef(), args.YByRef(), args.ClientIDByRef(), context);
				oprot->writeMessageBegin(thme_state,*reply,thme_header,thme_description);
				result_args.write(thme_state, *reply, oprot);
				oprot->writeMessageEnd(thme_state,*reply);
				context.outputTransport->sendMessage(reply);
			}
		}
		catch (const ::thrift::exceptions::TException& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing\n") +"\nException Message: " + ex.toString());
			}
		}
		catch (const std::exception& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing \n") +"\nException Message: " + ex.what());
			}
		}
	}

	void SeaBattleProcessor::process_subscribe(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		::thrift::protocol::TProtocol* iprot = context.inputTransport->getProtocol().get();

		SeaBattleParameters::subscribe_args args;
		args.read(*message, iprot);
		iprot->readMessageEnd(*message);
		::thrift::protocol::TMessageHeader thme_header(serviceId, SeaBattleFunctionIds::SUBSCRIBE_ID,::thrift::protocol::T_CALL,seqId);
		::thrift::protocol::TMessageDescription thme_description;
		try
		{
			::thrift::protocol::TProtocol* oprot = context.outputTransport->getProtocol().get();
			::thrift::protocol::TSerializationStatePtr thme_state = oprot->createState();
			std::shared_ptr< ::thrift::transport::TMessageBuffer > reply = std::make_shared<::thrift::transport::TMessageBuffer>(context.outputTransport->getAllocator());
			if (reply)
			{
				thme_header.type = ::thrift::protocol::T_REPLY;
				SeaBattleParameters::subscribe_result result_args;
				this->subscribe(args.ClientIDByRef(), context);
				oprot->writeMessageBegin(thme_state,*reply,thme_header,thme_description);
				result_args.write(thme_state, *reply, oprot);
				oprot->writeMessageEnd(thme_state,*reply);
				context.outputTransport->sendMessage(reply);
			}
		}
		catch (const ::thrift::exceptions::TException& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing\n") +"\nException Message: " + ex.toString());
			}
		}
		catch (const std::exception& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing \n") +"\nException Message: " + ex.what());
			}
		}
	}

	void SeaBattleProcessor::process_unsubscribe(int32_t seqId, int32_t serviceId, int32_t exFlags, const ::thrift::TCallContext& context, const std::shared_ptr< ::thrift::transport::TMessageBuffer >& message)
	{
		::thrift::protocol::TProtocol* iprot = context.inputTransport->getProtocol().get();

		SeaBattleParameters::unsubscribe_args args;
		args.read(*message, iprot);
		iprot->readMessageEnd(*message);
		::thrift::protocol::TMessageHeader thme_header(serviceId, SeaBattleFunctionIds::UNSUBSCRIBE_ID,::thrift::protocol::T_CALL,seqId);
		::thrift::protocol::TMessageDescription thme_description;
		try
		{
			::thrift::protocol::TProtocol* oprot = context.outputTransport->getProtocol().get();
			::thrift::protocol::TSerializationStatePtr thme_state = oprot->createState();
			std::shared_ptr< ::thrift::transport::TMessageBuffer > reply = std::make_shared<::thrift::transport::TMessageBuffer>(context.outputTransport->getAllocator());
			if (reply)
			{
				thme_header.type = ::thrift::protocol::T_REPLY;
				SeaBattleParameters::unsubscribe_result result_args;
				this->unsubscribe(args.ClientIDByRef(), context);
				oprot->writeMessageBegin(thme_state,*reply,thme_header,thme_description);
				result_args.write(thme_state, *reply, oprot);
				oprot->writeMessageEnd(thme_state,*reply);
				context.outputTransport->sendMessage(reply);
			}
		}
		catch (const ::thrift::exceptions::TException& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing\n") +"\nException Message: " + ex.toString());
			}
		}
		catch (const std::exception& ex)
		{
			std::shared_ptr<::thrift::logging::TLogModule> logModule = getServiceBroker()->getLogModuleShared();
			if (logModule && logModule->isLoggable(::thrift::logging::TLogLevel::LOG_ERROR))
			{
				logModule->logString(::thrift::logging::TLogLevel::LOG_ERROR,"::thrift::TServiceProcessor::FATAL: processing failed",std::string("Error during Processing \n") +"\nException Message: " + ex.what());
			}
		}
	}


	/**
	 * @param topicId The topic ID under which this event will be published. If the topic ID is 0 the event will be distributed to all clients. Otherwise it will be distributed by all multicast transports and all transports which are subscribed on the topic ID.
	 */
	void SeaBattleProcessor::oponentConectedEvent(const int16_t clientID,
		const int32_t topicId)
	{

		SeaBattleParameters::oponentConectedEvent_args args(clientID);
		int32_t serviceId = 0;
		{
			locks::TTempLock lock(getServiceLock());
			if (!isRegistered()) return;
			serviceId = getServiceId();
		}

		::thrift::protocol::TMessageHeader thme_header (serviceId, SeaBattleFunctionIds::OPONENT_CONECTED_EVENT_ID, ::thrift::protocol::T_EVENT, 0);
		::thrift::protocol::TMessageDescription thme_description;
		getServiceBroker()->dispatchEvent(&thme_description, &thme_header, SeaBattleFunctionIds::OPONENT_CONECTED_EVENT_ID, topicId, 0, &args, false);
	}

	/**
	 * @param topicId The topic ID under which this event will be published. If the topic ID is 0 the event will be distributed to all clients. Otherwise it will be distributed by all multicast transports and all transports which are subscribed on the topic ID.
	 */
	void SeaBattleProcessor::oponentShootEvent(const int32_t x,
		const int32_t y,
		const int16_t clientID,
		const int32_t topicId)
	{

		SeaBattleParameters::oponentShootEvent_args args(x, y, clientID);
		int32_t serviceId = 0;
		{
			locks::TTempLock lock(getServiceLock());
			if (!isRegistered()) return;
			serviceId = getServiceId();
		}

		::thrift::protocol::TMessageHeader thme_header (serviceId, SeaBattleFunctionIds::OPONENT_SHOOT_EVENT_ID, ::thrift::protocol::T_EVENT, 0);
		::thrift::protocol::TMessageDescription thme_description;
		getServiceBroker()->dispatchEvent(&thme_description, &thme_header, SeaBattleFunctionIds::OPONENT_SHOOT_EVENT_ID, topicId, 0, &args, false);
	}

	/**
	 * @param topicId The topic ID under which this event will be published. If the topic ID is 0 the event will be distributed to all clients. Otherwise it will be distributed by all multicast transports and all transports which are subscribed on the topic ID.
	 */
	void SeaBattleProcessor::shootResponseEvent(const ::SeaBattle::ShootRezult::type& rezult,
		const int16_t clientID,
		const int32_t topicId)
	{

		SeaBattleParameters::shootResponseEvent_args args(rezult, clientID);
		int32_t serviceId = 0;
		{
			locks::TTempLock lock(getServiceLock());
			if (!isRegistered()) return;
			serviceId = getServiceId();
		}

		::thrift::protocol::TMessageHeader thme_header (serviceId, SeaBattleFunctionIds::SHOOT_RESPONSE_EVENT_ID, ::thrift::protocol::T_EVENT, 0);
		::thrift::protocol::TMessageDescription thme_description;
		getServiceBroker()->dispatchEvent(&thme_description, &thme_header, SeaBattleFunctionIds::SHOOT_RESPONSE_EVENT_ID, topicId, 0, &args, false);
	}

	/**
	 * @param topicId The topic ID under which this event will be published. If the topic ID is 0 the event will be distributed to all clients. Otherwise it will be distributed by all multicast transports and all transports which are subscribed on the topic ID.
	 */
	void SeaBattleProcessor::gameOver(const bool rezult,
		const int16_t clientID,
		const int32_t topicId)
	{

		SeaBattleParameters::gameOver_args args(rezult, clientID);
		int32_t serviceId = 0;
		{
			locks::TTempLock lock(getServiceLock());
			if (!isRegistered()) return;
			serviceId = getServiceId();
		}

		::thrift::protocol::TMessageHeader thme_header (serviceId, SeaBattleFunctionIds::GAME_OVER_ID, ::thrift::protocol::T_EVENT, 0);
		::thrift::protocol::TMessageDescription thme_description;
		getServiceBroker()->dispatchEvent(&thme_description, &thme_header, SeaBattleFunctionIds::GAME_OVER_ID, topicId, 0, &args, false);
	}

	namespace SeaBattleParameters
	{
		void oponentConectedEvent_args::read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot)
		{
			std::string fname;
			::thrift::protocol::TType ftype;
			int16_t fid;

			while (true)
			{
				iprot->readFieldBegin(buffer, fname, ftype, fid);
				if (ftype == ::thrift::protocol::T_STOP)
				{
					  break;
				}
				switch (fid)
				{
					case 1:
						if (ftype == ::thrift::protocol::T_I16)
						{
							iprot->readI16(buffer, _clientID);
							__isset.clientID = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					default: 
						iprot->skip(buffer, ftype);
						break;
				}
				iprot->readFieldEnd(buffer);
			}
		}

		void oponentConectedEvent_args::write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const
		{
			if (__isset.clientID)
			{
				oprot->writeFieldBegin(thme_state,buffer, "clientID", ::thrift::protocol::T_I16, 1);
				oprot->writeI16(thme_state,buffer, _clientID);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			oprot->writeFieldStop(thme_state,buffer);
		}

		void oponentShootEvent_args::read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot)
		{
			std::string fname;
			::thrift::protocol::TType ftype;
			int16_t fid;

			while (true)
			{
				iprot->readFieldBegin(buffer, fname, ftype, fid);
				if (ftype == ::thrift::protocol::T_STOP)
				{
					  break;
				}
				switch (fid)
				{
					case 1:
						if (ftype == ::thrift::protocol::T_I32)
						{
							iprot->readI32(buffer, _x);
							__isset.x = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					case 2:
						if (ftype == ::thrift::protocol::T_I32)
						{
							iprot->readI32(buffer, _y);
							__isset.y = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					case 3:
						if (ftype == ::thrift::protocol::T_I16)
						{
							iprot->readI16(buffer, _clientID);
							__isset.clientID = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					default: 
						iprot->skip(buffer, ftype);
						break;
				}
				iprot->readFieldEnd(buffer);
			}
		}

		void oponentShootEvent_args::write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const
		{
			if (__isset.x)
			{
				oprot->writeFieldBegin(thme_state,buffer, "x", ::thrift::protocol::T_I32, 1);
				oprot->writeI32(thme_state,buffer, _x);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			if (__isset.y)
			{
				oprot->writeFieldBegin(thme_state,buffer, "y", ::thrift::protocol::T_I32, 2);
				oprot->writeI32(thme_state,buffer, _y);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			if (__isset.clientID)
			{
				oprot->writeFieldBegin(thme_state,buffer, "clientID", ::thrift::protocol::T_I16, 3);
				oprot->writeI16(thme_state,buffer, _clientID);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			oprot->writeFieldStop(thme_state,buffer);
		}

		void setShootResponse_args::read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot)
		{
			std::string fname;
			::thrift::protocol::TType ftype;
			int16_t fid;

			while (true)
			{
				iprot->readFieldBegin(buffer, fname, ftype, fid);
				if (ftype == ::thrift::protocol::T_STOP)
				{
					  break;
				}
				switch (fid)
				{
					case 1:
						if (ftype == ::thrift::protocol::T_I32)
						{
							int32_t ecast0;
							iprot->readI32(buffer, ecast0);
							_rezult = (::SeaBattle::ShootRezult::type)ecast0;
							__isset.rezult = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					case 2:
						if (ftype == ::thrift::protocol::T_I16)
						{
							iprot->readI16(buffer, _clientID);
							__isset.clientID = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					default: 
						iprot->skip(buffer, ftype);
						break;
				}
				iprot->readFieldEnd(buffer);
			}
		}

		void setShootResponse_args::write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const
		{
			if (__isset.rezult)
			{
				oprot->writeFieldBegin(thme_state,buffer, "rezult", ::thrift::protocol::T_I32, 1);
				oprot->writeEnum(thme_state,buffer, (int32_t)(_rezult),SeaBattle::ShootRezult::GetName((int32_t)(_rezult),"ERROR"));
				oprot->writeFieldEnd(thme_state,buffer);
			}
			if (__isset.clientID)
			{
				oprot->writeFieldBegin(thme_state,buffer, "clientID", ::thrift::protocol::T_I16, 2);
				oprot->writeI16(thme_state,buffer, _clientID);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			oprot->writeFieldStop(thme_state,buffer);
		}

		void gameOver_args::read(::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* iprot)
		{
			std::string fname;
			::thrift::protocol::TType ftype;
			int16_t fid;

			while (true)
			{
				iprot->readFieldBegin(buffer, fname, ftype, fid);
				if (ftype == ::thrift::protocol::T_STOP)
				{
					  break;
				}
				switch (fid)
				{
					case 1:
						if (ftype == ::thrift::protocol::T_BOOL)
						{
							iprot->readBool(buffer, _rezult);
							__isset.rezult = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					case 2:
						if (ftype == ::thrift::protocol::T_I16)
						{
							iprot->readI16(buffer, _clientID);
							__isset.clientID = true;
						}
						else iprot->skip(buffer, ftype);
						break;
					default: 
						iprot->skip(buffer, ftype);
						break;
				}
				iprot->readFieldEnd(buffer);
			}
		}

		void gameOver_args::write(::thrift::protocol::TSerializationStatePtr &thme_state,::thrift::transport::TMessageBuffer& buffer, ::thrift::protocol::TProtocol* oprot) const
		{
			if (__isset.rezult)
			{
				oprot->writeFieldBegin(thme_state,buffer, "rezult", ::thrift::protocol::T_BOOL, 1);
				oprot->writeBool(thme_state,buffer, _rezult);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			if (__isset.clientID)
			{
				oprot->writeFieldBegin(thme_state,buffer, "clientID", ::thrift::protocol::T_I16, 2);
				oprot->writeI16(thme_state,buffer, _clientID);
				oprot->writeFieldEnd(thme_state,buffer);
			}
			oprot->writeFieldStop(thme_state,buffer);
		}

	}

}
